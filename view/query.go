package view

import (
	"fmt"

	"github.com/flanksource/duty/context"
	"github.com/flanksource/duty/dataquery"
	"github.com/flanksource/duty/db"
	"github.com/flanksource/duty/query"
	"github.com/flanksource/duty/types"
)

// +kubebuilder:object:generate=true
type ViewSelector struct {
	Name          string `yaml:"name,omitempty" json:"name,omitempty"`
	Namespace     string `yaml:"namespace,omitempty" json:"namespace,omitempty"`
	LabelSelector string `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty"`
}

const TemplateVarsContextKey context.ContextKey = "view.template.vars"

// +kubebuilder:object:generate=true
type QueryForEach struct {
	Name       string                 `json:"name" yaml:"name"`
	Connection types.ResourceSelector `json:"connection,omitempty" yaml:"connection,omitempty"`
}

func (vs *ViewSelector) IsEmpty() bool {
	return vs.Name == "" && vs.Namespace == "" && vs.LabelSelector == ""
}

func (vs *ViewSelector) ToResourceSelector() types.ResourceSelector {
	return types.ResourceSelector{
		Name:          vs.Name,
		Namespace:     vs.Namespace,
		LabelSelector: vs.LabelSelector,
	}
}

func QueryViewTables(ctx context.Context, selector ViewSelector) ([]dataquery.QueryResultRow, error) {
	var results []dataquery.QueryResultRow

	views, err := query.FindViews(ctx, -1, selector.ToResourceSelector())
	if err != nil {
		return nil, fmt.Errorf("failed to find views: %w", err)
	}

	for _, view := range views {
		tableName := view.GeneratedTableName()
		rows, err := db.ReadTable(ctx.DB(), tableName)
		if err != nil {
			return nil, fmt.Errorf("failed to read table %s: %w", tableName, err)
		}

		for _, row := range rows {
			results = append(results, row)
		}
	}

	return results, nil
}

// +kubebuilder:object:generate=true
type Query struct {
	dataquery.Query `json:",inline" yaml:",inline" template:"true"`

	// Configs queries config items
	Configs *types.ResourceSelector `json:"configs,omitempty" yaml:"configs,omitempty" template:"true"`

	// Changes queries config changes
	Changes *types.ResourceSelector `json:"changes,omitempty" yaml:"changes,omitempty" template:"true"`

	// ViewTableSelector queries data from tables generated by other views
	ViewTableSelector *ViewSelector `json:"viewTableSelector,omitempty" yaml:"viewTableSelector,omitempty" template:"true"`

	ForEach *QueryForEach `json:"forEach,omitempty" yaml:"forEach,omitempty"`
}

func (v *Query) IsEmpty() bool {
	configsEmpty := v.Configs == nil || v.Configs.IsEmpty()
	changesEmpty := v.Changes == nil || v.Changes.IsEmpty()
	viewTablesEmpty := v.ViewTableSelector == nil || v.ViewTableSelector.IsEmpty()

	return configsEmpty && changesEmpty && viewTablesEmpty && v.Query.IsEmpty()
}

func templateVarsFromContext(ctx context.Context) map[string]any {
	val := ctx.Value(TemplateVarsContextKey)
	if val == nil {
		return nil
	}

	switch vars := val.(type) {
	case map[string]any:
		return vars
	case map[string]string:
		output := make(map[string]any, len(vars))
		for k, v := range vars {
			output[k] = v
		}
		return output
	default:
		return nil
	}
}

func copyQuery(q Query) Query {
	out := q

	if q.Configs != nil {
		cfg := *q.Configs
		out.Configs = &cfg
	}
	if q.Changes != nil {
		ch := *q.Changes
		out.Changes = &ch
	}
	if q.ViewTableSelector != nil {
		vs := *q.ViewTableSelector
		out.ViewTableSelector = &vs
	}
	if q.Prometheus != nil {
		p := *q.Prometheus
		out.Prometheus = &p
	}
	if q.SQL != nil {
		s := *q.SQL
		out.SQL = &s
	}
	if q.ForEach != nil {
		f := *q.ForEach
		out.ForEach = &f
	}

	return out
}

// ExecuteQuery executes a single query and returns results with query name
func ExecuteQuery(ctx context.Context, q Query) ([]dataquery.QueryResultRow, error) {
	if q.ForEach != nil {
		if q.ForEach.Name == "" {
			return nil, fmt.Errorf("forEach.name is required")
		}
		if q.ForEach.Connection.IsEmpty() {
			return nil, fmt.Errorf("forEach.connection is required")
		}

		connections, err := query.FindConnectionsByResourceSelector(ctx, -1, q.ForEach.Connection)
		if err != nil {
			return nil, fmt.Errorf("failed to find connections: %w", err)
		}

		var results []dataquery.QueryResultRow
		templateVars := templateVarsFromContext(ctx)
		for _, conn := range connections {
			queryCopy := copyQuery(q)
			queryCopy.ForEach = nil

			env := map[string]any{}
			if len(templateVars) > 0 {
				env["var"] = templateVars
			}
			env["forEach"] = map[string]any{
				q.ForEach.Name: map[string]any{
					"id":        conn.ID.String(),
					"name":      conn.Name,
					"namespace": conn.Namespace,
					"type":      conn.Type,
				},
			}

			st := ctx.NewStructTemplater(env, "", nil)
			if err := st.Walk(&queryCopy); err != nil {
				return nil, fmt.Errorf("failed to template forEach[%s]: %w", q.ForEach.Name, err)
			}

			iterResults, err := ExecuteQuery(ctx, queryCopy)
			if err != nil {
				return nil, err
			}
			results = append(results, iterResults...)
		}

		return results, nil
	}

	var results []dataquery.QueryResultRow
	if q.Configs != nil && !q.Configs.IsEmpty() {
		configs, err := query.FindConfigsByResourceSelector(ctx, -1, *q.Configs)
		if err != nil {
			return nil, fmt.Errorf("failed to find configs: %w", err)
		}

		for _, config := range configs {
			results = append(results, config.AsMap())
		}
	} else if q.Changes != nil && !q.Changes.IsEmpty() {
		changes, err := query.FindConfigChangesByResourceSelector(ctx, -1, *q.Changes)
		if err != nil {
			return nil, fmt.Errorf("failed to find changes: %w", err)
		}

		for _, change := range changes {
			results = append(results, change.AsMap())
		}
	} else if q.ViewTableSelector != nil && !q.ViewTableSelector.IsEmpty() {
		viewTableResults, err := QueryViewTables(ctx, *q.ViewTableSelector)
		if err != nil {
			return nil, fmt.Errorf("failed to query view tables: %w", err)
		}

		results = append(results, viewTableResults...)
	} else {
		return dataquery.ExecuteQuery(ctx, q.Query)
	}

	return results, nil
}
